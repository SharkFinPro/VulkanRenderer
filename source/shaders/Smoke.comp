#version 450

struct Particle {
  vec3 position;
  float ttl;
  vec3 velocity;
  vec4 color;
  vec3 initialPosition;
  vec3 initialVelocity;
};

layout(binding = 0) uniform ParameterUBO {
  float deltaTime;
} ubo;

layout(set = 0, binding = 4) uniform Smoke {
  float spreadFactor;
  float maxSpreadDistance;
  float windStrength;
} smoke;

layout(std140, binding = 1) readonly buffer ParticleSSBOIn {
  Particle particlesIn[ ];
};

layout(std140, binding = 2) buffer ParticleSSBOOut {
  Particle particlesOut[ ];
};

layout (local_size_x = 256, local_size_y = 1, local_size_z = 1) in;

const float TTL = 8.0;

vec3 applyWind(vec3 position, float time)
{
  vec3 windDir = vec3(sin(time * 0.1), 0.0, cos(time * 0.3));

  float turbulence = sin(position.y * 0.5 + time) * 0.15 +
  cos(position.x * 0.3 + time * 0.7) * 0.1;

  return windDir * smoke.windStrength + vec3(turbulence, 0.0, turbulence);
}

vec3 generateSpreadDirection(vec3 position, float ttl)
{
  vec3 direction = normalize(position - vec3(0.0));

  if(length(direction) < 0.01)
  {
    direction = normalize(vec3(sin(ttl * 3.14159 * 7.0), cos(ttl * 3.14159 * 11.0), sin(ttl * 3.14159 * 13.0)));
  }

  return direction;
}

vec3 calcSpreadForce(Particle particle)
{
  float normalizedTime = particle.ttl / TTL; // Value from 0 to 1
  float spreadStrength = min(smoke.spreadFactor * log(1 + 20 * normalizedTime), 0.5);

  vec3 spreadDirection = generateSpreadDirection(particle.position, particle.ttl);

  vec3 spreadForce = spreadDirection * spreadStrength;

  float distFromOrigin = length(particle.position);
  if (distFromOrigin > smoke.maxSpreadDistance)
  {
    spreadForce -= normalize(particle.position) * 0.05 * (distFromOrigin - smoke.maxSpreadDistance);
  }

  return spreadForce;
}

void main()
{
  uint index = gl_GlobalInvocationID.x;

  Particle particle = particlesIn[index];

  particle.ttl += ubo.deltaTime;

  particlesOut[index].ttl = particle.ttl;

  if (particle.ttl > TTL)
  {
    particle.position = particle.initialPosition;
    particle.velocity = particle.initialVelocity;
    particle.ttl = TTL - particle.ttl;

    particlesOut[index] = particle;

    return;
  }

  if (particle.ttl > 0.0)
  {
    vec3 wind = applyWind(particle.position, particle.ttl);

    vec3 spreadForce = calcSpreadForce(particle);

    particle.velocity += (wind + spreadForce) * ubo.deltaTime;
    particle.position += particle.velocity * ubo.deltaTime;
    particle.color.a = sqrt((TTL - particle.ttl) / TTL);
  }
  else
  {
    particle.color.a = 0.0;
  }

  particlesOut[index] = particle;
}